###############################
def _filecheck_test_impl(ctx):

    if False: # ctx.attr.is_windows:
        None
#         test_bin = ctx.actions.declare_file(ctx.label.name + "-test.bat")
#         ctx.actions.write(
#             output = test_bin,
#             content = """@rem Generated by diff_test.bzl, do not edit.
# """
#         )
    else:  ## not windows
        test_bin = ctx.actions.declare_file(ctx.label.name + "_filecheck_test.sh")
        ctx.actions.write(
            output = test_bin,
            content = r"""#!/usr/bin/env bash
{filecheck} {options} {match} --input-file {input}
""".format(
    filecheck = ctx.file._tool.path,
    options = " ".join(ctx.attr.opts),
    match = ctx.file.match_file.path,
    input = ctx.file.data.short_path
)
        )

    return DefaultInfo(
        executable = test_bin,
        files = depset(direct = [test_bin]),
        runfiles = ctx.runfiles(
            files = [test_bin,
                     ctx.file._tool,
                     ctx.file.match_file,
                     ctx.file.data]
        )
    )

#########################
filecheck_test = rule(
  implementation = _filecheck_test_impl,
    doc = """Runs FileCheck""",
    attrs = dict(
        _tool = attr.label(
            default = "@llvm_sdk//sdk/bin:FileCheck",
            allow_single_file = True,
            executable = True,
            cfg = "exec"
        ),
        opts = attr.string_list(),
        match_file = attr.label(
            mandatory = True,
            allow_single_file = True
        ),
        data = attr.label(
            mandatory = True,
            allow_single_file = True
        ),
    ),
    executable = True,
    test = True
)

################################################################
def _bitcode_gen_impl(ctx):

    print("BITCODE gen: %s" % ctx.outputs.out)

    ctx.actions.run(
        outputs = [ctx.outputs.out],
        tools = [ctx.executable.tool],
        executable = ctx.executable.tool,
        arguments = [ctx.outputs.out.path],
        mnemonic = "BitcodeGen",
        # use_default_shell_env = False,
        # env = dicts.add(ctx.configuration.default_shell_env, envs),
    )
    return DefaultInfo(
        files = depset([ctx.outputs.out]),
        runfiles = ctx.runfiles(files = [ctx.outputs.out]),
    )
## end of _bitcode_gen_impl

#########################
bitcode_gen = rule(
  implementation = _bitcode_gen_impl,
    doc = """Runs tool that generates bitcode file""",
    attrs = dict(
        tool = attr.label(
            mandatory  = True,
            allow_single_file = True,
            executable = True,
            cfg = "exec"
        ),
        opts = attr.string_list(),
        out = attr.output(
            mandatory = True,
        ),
    ),
    # executable = True,
)
################################################################
def _llvm_dis_impl(ctx):

    print("llvm-dis: %s" % ctx.file.bitcode)

    ctx.actions.run(
        inputs  = [ctx.file.bitcode],
        outputs = [ctx.outputs.ll],
        tools = [ctx.executable._tool],
        executable = ctx.executable._tool,
        arguments = [
            ctx.file.bitcode.path,
            "-o", ctx.outputs.ll.path
        ],
        mnemonic = "LlvmDisassembler",
        # use_default_shell_env = False,
        # env = dicts.add(ctx.configuration.default_shell_env, envs),
    )
    return DefaultInfo(
        files = depset([ctx.outputs.ll]),
        runfiles = ctx.runfiles(files = [ctx.outputs.ll]),
    )
## end of _llvm_dis_impl

#########################
llvm_dis = rule(
  implementation = _llvm_dis_impl,
    doc = """Runs llvm-dis tool""",
    attrs = dict(
        _tool = attr.label(
            default = "@llvm_sdk//sdk/bin:llvm-dis",
            allow_single_file = True,
            executable = True,
            cfg = "exec"
        ),
        opts = attr.string_list(),
        bitcode = attr.label(
            mandatory = True,
            allow_single_file = True
        ),
        ll = attr.output(
            mandatory = True,
        ),
    ),
)
